package com.proximaai.domain.entity.ai;

import jakarta.persistence.*;
import jakarta.validation.constraints.NotBlank;
import jakarta.validation.constraints.Size;
import jakarta.validation.constraints.Positive;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;

import com.proximaai.domain.entity.Project;
import com.proximaai.domain.entity.Task;

@Entity
@Table(name = "ai_task_clusters")
@EntityListeners(AuditingEntityListener.class)
public class TaskCluster {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @NotBlank
    @Size(min = 2, max = 100)
    @Column(name = "cluster_name", nullable = false)
    private String clusterName;

    @Size(max = 500)
    @Column(name = "cluster_description")
    private String clusterDescription;

    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "project_id")
    private Project project; // Opcional - pode ser cluster geral

    @Column(name = "cluster_type")
    @Enumerated(EnumType.STRING)
    private ClusterType clusterType = ClusterType.FUNCTIONAL;

    @Column(name = "similarity_threshold", precision = 5, scale = 4)
    @Positive
    private BigDecimal similarityThreshold; // Threshold m√≠nimo para inclus√£o no cluster

    @Column(name = "cluster_cohesion_score", precision = 5, scale = 4)
    @Positive
    private BigDecimal clusterCohesionScore; // Score de coes√£o interna do cluster

    @Column(name = "cluster_size")
    @Positive
    private Integer clusterSize; // Quantidade de tarefas no cluster

    @Column(name = "algorithm_used")
    private String algorithmUsed; // Algoritmo de ML usado (K-means, DBSCAN, etc.)

    @Column(name = "cluster_centroid")
    private String clusterCentroid; // JSON com caracter√≠sticas do centroide

    @Column(name = "cluster_features")
    private String clusterFeatures; // JSON com features utilizadas para clusteriza√ß√£o

    @Column(name = "cluster_metadata")
    private String clusterMetadata; // JSON com metadados do cluster

    @Column(name = "is_auto_generated")
    private Boolean isAutoGenerated = true; // Se foi gerado automaticamente

    @Column(name = "is_manually_adjusted")
    private Boolean isManuallyAdjusted = false; // Se foi ajustado manualmente

    @Column(name = "cluster_quality_score")
    private BigDecimal clusterQualityScore; // Score de qualidade do cluster

    @Column(name = "cluster_stability_score")
    private BigDecimal clusterStabilityScore; // Score de estabilidade ao longo do tempo

    @Column(name = "last_recalculation_date")
    private LocalDateTime lastRecalculationDate;

    @Column(name = "recalculation_frequency_days")
    private Integer recalculationFrequencyDays = 7; // Frequ√™ncia de rec√°lculo

    @Column(name = "ai_model_version")
    private String aiModelVersion; // Vers√£o do modelo de IA usado

    @Column(name = "processing_time_ms")
    private Long processingTimeMs; // Tempo de processamento em milissegundos

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    // Relacionamento com tarefas (muitas tarefas podem estar em um cluster)
    @OneToMany(mappedBy = "cluster", cascade = CascadeType.ALL, fetch = FetchType.LAZY, orphanRemoval = true)
    private List<ClusterTask> clusterTasks = new ArrayList<>();

    // Enums
    public enum ClusterType {
        FUNCTIONAL,     // Por funcionalidade
        TECHNICAL,      // Por tecnologia
        PRIORITY,       // Por prioridade
        COMPLEXITY,     // Por complexidade
        TEAM,          // Por equipe respons√°vel
        DEADLINE,       // Por prazo
        DEPENDENCY,     // Por depend√™ncias
        SKILL,         // Por habilidades necess√°rias
        CUSTOM         // Customizado
    }

    // Constructors
    public TaskCluster() {}

    public TaskCluster(String clusterName, ClusterType clusterType, BigDecimal similarityThreshold) {
        this.clusterName = clusterName;
        this.clusterType = clusterType;
        this.similarityThreshold = similarityThreshold;
    }

    // Helper methods
    public void addTask(Task task, BigDecimal similarityScore) {
        ClusterTask clusterTask = new ClusterTask(this, task, similarityScore);
        this.clusterTasks.add(clusterTask);
        this.clusterSize = this.clusterTasks.size();
    }

    public void removeTask(Task task) {
        this.clusterTasks.removeIf(ct -> ct.getTask().equals(task));
        this.clusterSize = this.clusterTasks.size();
    }

    public boolean isStable() {
        return this.clusterStabilityScore != null && 
               this.clusterStabilityScore.compareTo(new BigDecimal("0.8")) > 0;
    }

    public boolean isHighQuality() {
        return this.clusterQualityScore != null && 
               this.clusterQualityScore.compareTo(new BigDecimal("0.7")) > 0;
    }

    public boolean needsRecalculation() {
        if (this.lastRecalculationDate == null) return true;
        
        LocalDateTime nextCalculation = this.lastRecalculationDate.plusDays(
            this.recalculationFrequencyDays != null ? this.recalculationFrequencyDays : 7
        );
        return LocalDateTime.now().isAfter(nextCalculation);
    }

    public String getClusterIcon() {
        switch (this.clusterType) {
            case FUNCTIONAL: return "üîß";
            case TECHNICAL: return "üíª";
            case PRIORITY: return "‚ö°";
            case COMPLEXITY: return "üß©";
            case TEAM: return "üë•";
            case DEADLINE: return "‚è∞";
            case DEPENDENCY: return "üîó";
            case SKILL: return "üéØ";
            case CUSTOM: return "üé®";
            default: return "üìã";
        }
    }

    public void recalculateCluster() {
        this.lastRecalculationDate = LocalDateTime.now();
        // L√≥gica de rec√°lculo seria implementada no servi√ßo
    }

    // Getters and Setters
    public Long getId() {
        return id;
    }

    public void setId(Long id) {
        this.id = id;
    }

    public String getClusterName() {
        return clusterName;
    }

    public void setClusterName(String clusterName) {
        this.clusterName = clusterName;
    }

    public String getClusterDescription() {
        return clusterDescription;
    }

    public void setClusterDescription(String clusterDescription) {
        this.clusterDescription = clusterDescription;
    }

    public Project getProject() {
        return project;
    }

    public void setProject(Project project) {
        this.project = project;
    }

    public ClusterType getClusterType() {
        return clusterType;
    }

    public void setClusterType(ClusterType clusterType) {
        this.clusterType = clusterType;
    }

    public BigDecimal getSimilarityThreshold() {
        return similarityThreshold;
    }

    public void setSimilarityThreshold(BigDecimal similarityThreshold) {
        this.similarityThreshold = similarityThreshold;
    }

    public BigDecimal getClusterCohesionScore() {
        return clusterCohesionScore;
    }

    public void setClusterCohesionScore(BigDecimal clusterCohesionScore) {
        this.clusterCohesionScore = clusterCohesionScore;
    }

    public Integer getClusterSize() {
        return clusterSize;
    }

    public void setClusterSize(Integer clusterSize) {
        this.clusterSize = clusterSize;
    }

    public String getAlgorithmUsed() {
        return algorithmUsed;
    }

    public void setAlgorithmUsed(String algorithmUsed) {
        this.algorithmUsed = algorithmUsed;
    }

    public String getClusterCentroid() {
        return clusterCentroid;
    }

    public void setClusterCentroid(String clusterCentroid) {
        this.clusterCentroid = clusterCentroid;
    }

    public String getClusterFeatures() {
        return clusterFeatures;
    }

    public void setClusterFeatures(String clusterFeatures) {
        this.clusterFeatures = clusterFeatures;
    }

    public String getClusterMetadata() {
        return clusterMetadata;
    }

    public void setClusterMetadata(String clusterMetadata) {
        this.clusterMetadata = clusterMetadata;
    }

    public Boolean getIsAutoGenerated() {
        return isAutoGenerated;
    }

    public void setIsAutoGenerated(Boolean isAutoGenerated) {
        this.isAutoGenerated = isAutoGenerated;
    }

    public Boolean getIsManuallyAdjusted() {
        return isManuallyAdjusted;
    }

    public void setIsManuallyAdjusted(Boolean isManuallyAdjusted) {
        this.isManuallyAdjusted = isManuallyAdjusted;
    }

    public BigDecimal getClusterQualityScore() {
        return clusterQualityScore;
    }

    public void setClusterQualityScore(BigDecimal clusterQualityScore) {
        this.clusterQualityScore = clusterQualityScore;
    }

    public BigDecimal getClusterStabilityScore() {
        return clusterStabilityScore;
    }

    public void setClusterStabilityScore(BigDecimal clusterStabilityScore) {
        this.clusterStabilityScore = clusterStabilityScore;
    }

    public LocalDateTime getLastRecalculationDate() {
        return lastRecalculationDate;
    }

    public void setLastRecalculationDate(LocalDateTime lastRecalculationDate) {
        this.lastRecalculationDate = lastRecalculationDate;
    }

    public Integer getRecalculationFrequencyDays() {
        return recalculationFrequencyDays;
    }

    public void setRecalculationFrequencyDays(Integer recalculationFrequencyDays) {
        this.recalculationFrequencyDays = recalculationFrequencyDays;
    }

    public String getAiModelVersion() {
        return aiModelVersion;
    }

    public void setAiModelVersion(String aiModelVersion) {
        this.aiModelVersion = aiModelVersion;
    }

    public Long getProcessingTimeMs() {
        return processingTimeMs;
    }

    public void setProcessingTimeMs(Long processingTimeMs) {
        this.processingTimeMs = processingTimeMs;
    }

    public LocalDateTime getCreatedAt() {
        return createdAt;
    }

    public void setCreatedAt(LocalDateTime createdAt) {
        this.createdAt = createdAt;
    }

    public List<ClusterTask> getClusterTasks() {
        return clusterTasks;
    }

    public void setClusterTasks(List<ClusterTask> clusterTasks) {
        this.clusterTasks = clusterTasks;
    }
}

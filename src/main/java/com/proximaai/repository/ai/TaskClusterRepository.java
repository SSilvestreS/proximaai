package com.proximaai.repository.ai;

import com.proximaai.domain.entity.ai.TaskCluster;
import com.proximaai.domain.entity.Project;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.query.Param;
import org.springframework.stereotype.Repository;

import java.math.BigDecimal;
import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

@Repository
public interface TaskClusterRepository extends JpaRepository<TaskCluster, Long> {

    /**
     * Busca clusters por projeto
     */
    List<TaskCluster> findByProjectOrderByCreatedAtDesc(Project project);

    /**
     * Busca clusters por tipo
     */
    List<TaskCluster> findByClusterType(TaskCluster.ClusterType clusterType);

    /**
     * Busca clusters por projeto e tipo
     */
    List<TaskCluster> findByProjectAndClusterTypeOrderByCreatedAtDesc(Project project, TaskCluster.ClusterType clusterType);

    /**
     * Busca clusters gerados automaticamente
     */
    List<TaskCluster> findByIsAutoGeneratedTrue();

    /**
     * Busca clusters ajustados manualmente
     */
    List<TaskCluster> findByIsManuallyAdjustedTrue();

    /**
     * Busca clusters ativos
     */
    List<TaskCluster> findByIsActiveTrue();

    /**
     * Busca clusters por algoritmo de ML
     */
    List<TaskCluster> findByAlgorithmUsed(String algorithmUsed);

    /**
     * Busca clusters com score de coesão acima do threshold
     */
    @Query("SELECT tc FROM TaskCluster tc WHERE tc.clusterCohesionScore >= :minCohesion")
    List<TaskCluster> findByCohesionScoreAbove(@Param("minCohesion") BigDecimal minCohesion);

    /**
     * Busca clusters com score de qualidade acima do threshold
     */
    @Query("SELECT tc FROM TaskCluster tc WHERE tc.clusterQualityScore >= :minQuality")
    List<TaskCluster> findByQualityScoreAbove(@Param("minQuality") BigDecimal minQuality);

    /**
     * Busca clusters com score de estabilidade acima do threshold
     */
    @Query("SELECT tc FROM TaskCluster tc WHERE tc.clusterStabilityScore >= :minStability")
    List<TaskCluster> findByStabilityScoreAbove(@Param("minStability") BigDecimal minStability);

    /**
     * Busca clusters por tamanho
     */
    @Query("SELECT tc FROM TaskCluster tc WHERE tc.clusterSize = :size")
    List<TaskCluster> findByClusterSize(@Param("size") Integer size);

    /**
     * Busca clusters com tamanho acima do threshold
     */
    @Query("SELECT tc FROM TaskCluster tc WHERE tc.clusterSize >= :minSize")
    List<TaskCluster> findByClusterSizeAbove(@Param("minSize") Integer minSize);

    /**
     * Busca clusters por período de criação
     */
    List<TaskCluster> findByCreatedAtBetween(LocalDateTime startDate, LocalDateTime endDate);

    /**
     * Busca clusters por período de recálculo
     */
    @Query("SELECT tc FROM TaskCluster tc WHERE tc.lastRecalculationDate BETWEEN :startDate AND :endDate")
    List<TaskCluster> findByRecalculationPeriod(@Param("startDate") LocalDateTime startDate, @Param("endDate") LocalDateTime endDate);

    /**
     * Busca clusters por frequência de recálculo
     */
    List<TaskCluster> findByRecalculationFrequencyDays(Integer frequencyDays);

    /**
     * Busca clusters por versão do modelo de IA
     */
    List<TaskCluster> findByAiModelVersion(String aiModelVersion);

    /**
     * Busca clusters com tempo de processamento abaixo do threshold
     */
    @Query("SELECT tc FROM TaskCluster tc WHERE tc.processingTimeMs <= :maxTime")
    List<TaskCluster> findByProcessingTimeBelow(@Param("maxTime") Long maxTime);

    /**
     * Busca clusters por projeto e período
     */
    @Query("SELECT tc FROM TaskCluster tc WHERE tc.project = :project AND tc.createdAt BETWEEN :startDate AND :endDate")
    List<TaskCluster> findByProjectAndPeriod(@Param("project") Project project, @Param("startDate") LocalDateTime startDate, @Param("endDate") LocalDateTime endDate);

    /**
     * Busca clusters por projeto e tipo ordenados
     */
    @Query("SELECT tc FROM TaskCluster tc WHERE tc.project = :project AND tc.clusterType = :clusterType ORDER BY tc.createdAt DESC")
    List<TaskCluster> findByProjectAndClusterTypeOrdered(@Param("project") Project project, @Param("clusterType") TaskCluster.ClusterType clusterType);

    /**
     * Conta clusters por tipo
     */
    @Query("SELECT tc.clusterType, COUNT(tc) FROM TaskCluster tc GROUP BY tc.clusterType")
    List<Object[]> countByClusterType();

    /**
     * Conta clusters por algoritmo
     */
    @Query("SELECT tc.algorithmUsed, COUNT(tc) FROM TaskCluster tc GROUP BY tc.algorithmUsed")
    List<Object[]> countByAlgorithm();

    /**
     * Busca clusters com features específicas
     */
    @Query("SELECT tc FROM TaskCluster tc WHERE tc.clusterFeatures LIKE %:feature%")
    List<TaskCluster> findByFeatureContaining(@Param("feature") String feature);

    /**
     * Busca clusters por projeto e score de qualidade
     */
    @Query("SELECT tc FROM TaskCluster tc WHERE tc.project = :project AND tc.clusterQualityScore >= :minQuality ORDER BY tc.clusterQualityScore DESC")
    List<TaskCluster> findByProjectAndQualityAbove(@Param("project") Project project, @Param("minQuality") BigDecimal minQuality);

    /**
     * Busca clusters por projeto e período de recálculo
     */
    @Query("SELECT tc FROM TaskCluster tc WHERE tc.project = :project AND tc.lastRecalculationDate >= :since ORDER BY tc.lastRecalculationDate DESC")
    List<TaskCluster> findRecentByProject(@Param("project") Project project, @Param("since") LocalDateTime since);

    /**
     * Busca clusters por projeto e status de geração
     */
    List<TaskCluster> findByProjectAndIsAutoGeneratedOrderByCreatedAtDesc(Project project, Boolean isAutoGenerated);
}
